% Chapter 3
\chapter{سیستم های مشابه}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{ابزار Modex}
Modex \cite{2}  ابزاری است که حدوداَ بیست سال پیش توسط جرارد هالزمن \LTRfootnote{Gerard Holzmann} توسعه یافته‌است. این ابزار  با استفاده از زبان C نوشته شده‌است و هدف آن استخراج خودکار مدل به زبان Promela از کد C است. این ابزار برنامه‌های  معمولی C را به شیوه‌ی معقولی به زبان Promela ترجمه می‌کند. اما هنوز محدودیت های آشکاری دارد‌؛ یعنی فقط از Promela به‌صورت محدودی استفاده می‌کند. به عنوان مثال، اشاره‌گر\LTRfootnote{pointer}ها را اداره نمی کند و هیچ فراخوانی رویه\LTRfootnote{procedure call} ای ندارد. از آنجا که Promela به اندازه‌ی زبان C قدرتمند نیست، بسیاری از انواع داده های انعطاف پذیر و عملکردهای مبتکرانه ی موجود در زبان C را نمی‌توان مستقیماً به Promela  ترجمه کرد. بنابراین، Modex  این کدهای ترجمه ناپذیر را به صورت مستقیم در کد Promela تعبیه می‌کند و به این صورت به این نوع امکانات زبان C رسیدگی می‌کند. قطعات کد تعبیه‌شده\LTRfootnote{embedded} را نمی‌توان با SPIN بررسی کرد؛ نه در مرحله تجزیه\LTRfootnote{parsing phase} و نه در مرحله تأیید\LTRfootnote{verification phase}. بنابراین، به آن‌ها به صورت کورکورانه اعتماد می‌شود، و از متن مدل، در کدی که Spin ایجاد می‌کند، کپی می‌شوند. به طور خاص، اگر یک قطعه کد C تعبیه‌شده شامل یک عملیات غیرمجاز باشد؛ مانند عملیات تقسیم بر صفر یا یک اشاره‌گر به فضای خالی\LTRfootnote{NULL pointer}؛ نتیجه می‌تواند در حالی که مدل بررسی می‌شود، مخرب باشد. برای ترجمه‌ی این بخش‌های کد C به Promela ، برای اینکه بتوان آن‌ها را با Spin مورد وارسی قرارداد، باید از روش‌های خلاقانه تری نسبت به Modex استفاده کرد. یکی از مهم‌ترین محدودیت های Modex ، ترجمه‌ی اشاره‌گرهاست. Modex در این حد  اشار‌ه‌گرها را کنترل می‌کند، که هنگام استفاده از آن‌ها، تاکید\LTRfootnote{assertion}هایی را ایجاد می‌کند؛ اما فقط برای اطمینان از این هستند که اشاره‏گرها به فضای خالی از حافظه ارجاع‌ داده‌نشده‌باشند. بنابراین، سعی نمی‌کند جزئیات را بررسی کند و مشکلات احتمالی هر اشاره‌گر را پیدا‌کند، و فقط به بررسی عدم اشاره‌ به فضای خالی از حافظه کفایت می‌کند.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{ابزار \lr{JPF(Java PathFinder)}}
JPF \cite{3} در ابتدا در سال 1999 به عنوان مترجمی از زیرمجموعه‌ای از Java - شامل ایجاد شی پویا\LTRfootnote{ dynamic object creation }، وراثت\LTRfootnote{ inheritance }، استثنائات\LTRfootnote{ exceptions } و عملیات مربوط به نخ های اجرا\LTRfootnote{ thread operations } - به Promela توسعه داده‌شد و از Spin برای بررسی مدل ترجمه شده استفاده‌کرد. این ابزار سعی می‌کرد کدهای Java را به کدهای با عملکردهای مشابه در Promela ترجمه کند. چند سال بعد، به عنوان یک ماشین مجازی Java \LTRfootnote{JVM} توسعه داده‌شد، که به طور خودکار تمام مسیرهای اجرای احتمالی یک برنامه را برای یافتن نقض ویژگی ها \LTRfootnote{violations of properties} مانند بن بست \LTRfootnote{deadlock} ها یا موارد استثنایی کنترل نشده \LTRfootnote{unhandled exceptions} مورد بررسی قرار‌می‌دهد.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{ابزار \lr{SDL2PML}}
\lr{SDL2PML} \cite{5} ابزاری برای تولید خودکار مدل Promela از SDL است. کاملاً مستقل است و به هیچ ابزار خارجی متکی نیست. به صورت خودکار مدل هایی را تولید می‌کند که می‌توان با Spin آن‎ها را ارزیابی کرد. مدل‌هایی که تولید می‌کند، می‌توانند شامل کد C تعبیه‌شده‌باشند؛ یعنی از این مزیت برخوردار است که بخش‌هایی از کد را که نمی‌تواند ترجمه کند، به صورت کدهای تعبیه‌شده ی C در کد Promela قرار دهد. این ابزار با موفقیت در مواردی برای تولید مدل در کاربردهای دنیای واقعی مورد استفاده قرار‌گرفته‌است. کاستی قابل‌توجهی که در این ابزار وجود دارد، عدم پشتیبانی برنامه‌های با اجرای چندخطی\LTRfootnote{multi-threaded execution}  است. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\lr{ke thesis}}
\lr{Ke Jiang} مقاله‌ای تحت عنوان \lr{Model Checking C Programs by Translating C to Promela} \cite{6} ارائه کرده‌است؛ که در آن روش‌هایی موثر برای استخراج کد Promela از کد C معرفی شده‌‌است. این روش‌ها با تمرکز بر روی ضعف‌های سایر ابزارهایی که از پیش وجود داشتند و برای رفع آن کاستی‌ها ارائه شده‌اند. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{نتیجه‌گیری}
با توجه به بررسی‌های صورت‌گرفته بر روی سیستم‌های مشابه، ابزار Modex بهترین ابزار دردسترس برای تبدیل کد C به Promela تشخیص‌داده‌شد. بنابراین، تصمیم بر بهبود برخی عملکردهای آن گرفته‌شد. می‌توان برای این کار، از روش‌های موجود در مقاله‌ی معرفی شده در بخش 3.4 الهام گرفت.
