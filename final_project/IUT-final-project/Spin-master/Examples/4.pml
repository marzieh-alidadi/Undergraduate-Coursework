// Generated by MODEX Version 2.11 - 3 November 2017
// ‫شنبه ۱۱ سپتامبر ۲۱، ساعات ۱۲:۲۸:۴۴ (+0430)‬ from 4_mutex.c

int res_p_main;
bool lck_p_main_ret;
bool lck_p_main;
 c_state "void  * par0_thread" "Global"
 c_state "void * res_p_thread" "Global"
bool lck_p_thread_ret;
bool lck_p_thread;
bool lck_p_unlock_ret;
bool lck_p_unlock;
int par0_lock;
bool lck_p_lock_ret;
bool lck_p_lock;
int cnt;
int x;
int y;
int z;
chan ret_p_main = [1] of { pid };
chan exc_cll_p_main = [0] of { pid };
chan req_cll_p_main = [1] of { pid };
chan ret_p_thread = [1] of { pid };
chan exc_cll_p_thread = [0] of { pid };
chan req_cll_p_thread = [1] of { pid };
chan ret_p_unlock = [1] of { pid };
chan exc_cll_p_unlock = [0] of { pid };
chan req_cll_p_unlock = [1] of { pid };
chan ret_p_lock = [1] of { pid };
chan exc_cll_p_lock = [0] of { pid };
chan req_cll_p_lock = [1] of { pid };
 c_state "void  * arg" "Local p_thread"
active [2] proctype p_lock( )
{
pid lck_id;
int Pid;
endRestart:
 atomic {
 nempty(req_cll_p_lock) && !lck_p_lock -> lck_p_lock = 1;
 req_cll_p_lock?lck_id; exc_cll_p_lock?eval(lck_id);
 c_code { Pp_lock->Pid = now.par0_lock; };
 lck_p_lock = 0;
 };
busywait:
    c_code { now.x=Pp_lock->Pid; };
    if
    :: c_expr { ((now.y!=0)&&(!pthread_equal(Pp_lock->Pid,now.y))) };
                goto busywait;
    :: c_expr { !((now.y!=0)&&(!pthread_equal(Pp_lock->Pid,now.y))) };
 fi;
    c_code { now.z=Pp_lock->Pid; };
    if
    :: c_expr { (!pthread_equal(now.x,Pp_lock->Pid)) };
                goto busywait;
    :: c_expr { !(!pthread_equal(now.x,Pp_lock->Pid)) };
 fi;
    c_code { now.y=Pp_lock->Pid; };
    if
    :: c_expr { (!pthread_equal(now.z,Pp_lock->Pid)) };
                goto busywait;
    :: c_expr { !(!pthread_equal(now.z,Pp_lock->Pid)) };
 fi;
Return: skip;
 ret_p_lock!lck_id;
 goto endRestart
}
active [2] proctype p_unlock()
{
pid lck_id;
endRestart:
 atomic {
 nempty(req_cll_p_unlock) && !lck_p_unlock -> lck_p_unlock = 1;
 req_cll_p_unlock?lck_id; exc_cll_p_unlock?eval(lck_id);
 lck_p_unlock = 0;
 };
    c_code { now.x=0; };
    c_code { now.y=0; };
    c_code { now.z=0; };
Return: skip;
 ret_p_unlock!lck_id;
 goto endRestart
}
active [2] proctype p_thread( )
{
pid lck_id;
endRestart:
 atomic {
 nempty(req_cll_p_thread) && !lck_p_thread -> lck_p_thread = 1;
 req_cll_p_thread?lck_id; exc_cll_p_thread?eval(lck_id);
 c_code { Pp_thread->arg = now.par0_thread; };
 lck_p_thread = 0;
 };
 atomic {
  lck_p_lock == 0 && empty(req_cll_p_lock) -> req_cll_p_lock!_pid;
  c_code { now.par0_lock = ((int)(((P0 *)this)->_pid)); };
  exc_cll_p_lock!_pid;
 }
 ret_p_lock?eval(_pid);
 c_code { ; now.lck_p_lock_ret = 0; };
c_code { now.cnt++; };
    c_code [(now.cnt==1)] { ; };
c_code { now.cnt--; };
 atomic {
  lck_p_unlock == 0 && empty(req_cll_p_unlock) -> req_cll_p_unlock!_pid;
  exc_cll_p_unlock!_pid;
 }
 ret_p_unlock?eval(_pid);
 c_code { ; now.lck_p_unlock_ret = 0; };
Return: skip;
 ret_p_thread!lck_id;
 goto endRestart
}
active proctype p_main( )
{
int t[2];
pid lck_id;
     atomic {
  lck_p_thread == 0 && empty(req_cll_p_thread) -> req_cll_p_thread!_pid;
  c_code { now.par0_thread = 0; };
  exc_cll_p_thread!_pid;
 }
     atomic {
  lck_p_thread == 0 && empty(req_cll_p_thread) -> req_cll_p_thread!_pid;
  c_code { now.par0_thread = 0; };
  exc_cll_p_thread!_pid;
 }
     ret_p_thread?eval(_pid);
 c_code { now.lck_p_thread_ret = 0; };
     ret_p_thread?eval(_pid);
 c_code { now.lck_p_thread_ret = 0; };
     atomic { !lck_p_main_ret -> lck_p_main_ret = 1 };
 c_code { now.res_p_main = (int ) 0; }; goto Return;
Return: skip;
}
